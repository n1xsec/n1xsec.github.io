<!DOCTYPE html>
<body>
    <head>
        <title>meow</title>
    </head>
    <h1>dont get raped young bull</h1>
    <script>/* ========================================================================
   istria.dev - AntiMonkey v1.1 (with fresh-realm anti-masking + debug)
   - Adds 3 new anti-masking checks:
       1) freshToStringMismatch   (cross-realm Function#toString)
       2) crossRealmConsoleProbe  (fresh realm examines page's console.log)
       3) descriptorWeirdness     (descriptor sanity for console methods)
   - Expanded debug logger: per-test evidence, console groups + tables.
   - Same public API: AntiMonkey.start({ onDetect, onScore, debug, ... })
   - Auto-start at the bottom (set debug as you like).
   ======================================================================== */

(() => {
  "use strict";

  const now = () => (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
  const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
  const isFn = (x) => typeof x === "function";
  const NATIVE_RX = /\[native code\]/i;

  // Known extension IDs (kept from v1.0; Firefox handled via moz-extension marker)
  const KNOWN_IDS = {
    chrome: {
      tampermonkey: ["dhdgffkkebhmkfjojejmpbldmpobfkfo"],
      violentmonkey: ["jinjaccalgkegednnccohejagnlnfdag"]
    },
    edge: {
      tampermonkey: ["iikmkjmpaadaobahmlepeloendndfphd"],
      violentmonkey: ["eeagobfjdenkkddmbclomhiblgggliao"]
    },
    opera: {
      tampermonkey: ["iikmkjmpaadaobahmlepeloendndfphd","dhdgffkkebhmkfjojejmpbldmpobfkfo"],
      violentmonkey: ["jinjaccalgkegednnccohejagnlnfdag"]
    },
    firefox: { tampermonkey:["moz-extension"], violentmonkey:["moz-extension"], greasemonkey:["moz-extension"] }
  };

  const EXT_RESOURCES = [
    "/images/icon128.png","/icons/icon128.png","/assets/icon128.png","/images/icon48.png","/assets/logo.png","/manifest.json"
  ];

  // Weights (bumped console + added the 3 new ones)
  const DEFAULT_WEIGHTS = {
    probeExtensionImage: 12,
    probeExtensionStylesheet: 10,
    scanResourceTimings: 6,
    scanDOMForExtensionScripts: 10,
    scanStylesForExtensionHrefs: 8,
    detectXHRHook: 6,
    detectFetchHook: 6,
    detectWebSocketHook: 4,
    detectConsoleHook: 8,           // was 2; give it real impact
    detectToStringTamper: 6,
    mutationScriptTrap: 5,
    baitAdRemovalTrap: 5,
    timingAnomaly: 3,
    checkWindowProps: 6,
    stackMozExtensionLeak: 10,
    detectExtensionIframes: 8,

    // NEW
    freshToStringMismatch: 18,
    crossRealmConsoleProbe: 16,
    descriptorWeirdness: 8
  };

  const looksNative = (fn) => {
    try {
      if (!isFn(fn)) return false;
      const s = Function.prototype.toString.call(fn);
      return NATIVE_RX.test(s);
    } catch { return false; }
  };

  const safeDesc = (obj, k) => { try { return Object.getOwnPropertyDescriptor(obj, k) || null; } catch { return null; } };
  const appendHidden = (el) => {
    try {
      el.style.cssText = "position:absolute;left:-99999px;top:-99999px;width:1px;height:1px;opacity:0;pointer-events:none;";
      (document.body || document.documentElement).appendChild(el);
      return true;
    } catch { return false; }
  };

  class AntiMonkey {
    static start(opts = {}) { const inst = new AntiMonkey(opts); inst.init(); return inst; }

    constructor(opts = {}) {
      this.opts = {
        weights: { ...DEFAULT_WEIGHTS, ...(opts.weights || {}) },
        continuous: opts.continuous !== false,
        intervalMinMs: opts.intervalMinMs || 4500,
        intervalMaxMs: opts.intervalMaxMs || 9000,
        runOnReadyState: opts.runOnReadyState || "interactive",
        onDetect: isFn(opts.onDetect) ? opts.onDetect : null,
        onScore: isFn(opts.onScore) ? opts.onScore : null,
        maxLog: opts.maxLog || 500,
        debug: !!opts.debug,
        threshold: typeof opts.threshold === "number" ? opts.threshold : 35
      };
      this.log = [];
      this.findings = [];
      this.listeners = new Set();
      this.timer = null; this.destroyed = false;

      // traps/baits
      this._mo = null; this._bait = null; this._adBait = null;
      this._lastPayload = null;
    }

    init() {
      const go = async () => { this._dinfo("init: DOM ready"); await this.runAll(); if (this.opts.continuous) this._loop(); };
      const s = document.readyState;
      (s === "complete" || s === "interactive") ? go() :
        document.addEventListener("readystatechange", () => {
          if (document.readyState === this.opts.runOnReadyState) go();
        }, { once: true });
    }

    destroy() { this.destroyed = true; if (this.timer) clearTimeout(this.timer); try { this._mo?.disconnect(); } catch{} }

    on(fn) { if (isFn(fn)) this.listeners.add(fn); return () => this.listeners.delete(fn); }
    _emit(p) { this._lastPayload = p; for (const l of this.listeners) try { l(p); } catch{} if (this.opts.onScore) try { this.opts.onScore(p);}catch{} if (p.suspected && this.opts.onDetect) try { this.opts.onDetect(p);}catch{} }
    lastReport(){ return this._lastPayload; }

    _loop() {
      if (this.destroyed) return;
      const ms = rand(this.opts.intervalMinMs, this.opts.intervalMaxMs);
      this._dinfo(`next scan in ${ms}ms`);
      this.timer = setTimeout(async () => { await this.runAll(); this._loop(); }, ms);
    }

    _l(level, msg, extra) {
      const e = { t: Date.now(), level, msg, extra: extra ?? null };
      this.log.push(e); if (this.log.length > this.opts.maxLog) this.log.shift();
      if (this.opts.debug) {
        const tag = `%c[AntiMonkey:${level}]`;
        const style = level === "error" ? "color:#ff5252" : level === "warn" ? "color:#ffb54c" : level === "debug" ? "color:#8ab4f8" : "color:#9be29b";
        try { console.log(tag, style, msg, extra ?? ""); } catch {}
      }
    }
    _dinfo(m,x){ this._l("info",m,x); }
    _dwarn(m,x){ this._l("warn",m,x); }
    _derr(m,x){ this._l("error",m,x); }
    _d(m,x){ this._l("debug",m,x); }

    _addFinding(id, passed, evidence, weightKey) {
      const weight = this.opts.weights[weightKey] || 0;
      const f = { id, weightKey, weight, passed: !!passed, score: passed ? weight : 0, ts: Date.now(), evidence };
      this.findings.push(f);
      if (this.opts.debug) this._debugPrintFinding(f);
      return f;
    }

    _aggregate() {
      const latest = new Map();
      for (let i = this.findings.length - 1; i >= 0; i--) if (!latest.has(this.findings[i].id)) latest.set(this.findings[i].id, this.findings[i]);
      const items = Array.from(latest.values());
      const total = items.reduce((a,b)=>a+b.weight,0)||1;
      const gained = items.reduce((a,b)=>a+(b.passed?b.weight:0),0);
      const score = clamp(Math.round(100*(gained/total)),0,100);
      const suspected = score >= this.opts.threshold;
      return { items, score, suspected, gained, total };
    }

    async runAll() {
      const t0 = now();
      this._prepareMutationBait(); this._prepareAdBait();

      const tasks = [
        this._probeExtensionImage(),
        this._probeExtensionStylesheet(),
        this._scanResourceTimings(),
        this._scanDOMForExtensionScripts(),
        this._scanStylesForExtensionHrefs(),
        this._detectXHRHook(),
        this._detectFetchHook(),
        this._detectWebSocketHook(),
        this._detectConsoleHook(),
        this._detectToStringTamper(),
        this._mutationScriptTrapCheck(),
        this._baitAdRemovalTrapCheck(),
        this._timingAnomalyCheck(),
        this._checkWindowProps(),
        this._stackMozExtensionLeak(),
        this._detectExtensionIframes(),

        // NEW anti-masking
        this._freshToStringMismatch(),
        this._crossRealmConsoleProbe(),
        this._descriptorWeirdness()
      ];

      const settled = await Promise.allSettled(tasks);
      const res = [];
      for (const s of settled) if (s.status === "fulfilled" && s.value) res.push(...(Array.isArray(s.value)?s.value:[s.value]));

      const agg = this._aggregate();
      const dt = Math.max(1, Math.round(now() - t0));
      const payload = { score: agg.score, suspected: agg.suspected, findings: agg.items, gained: agg.gained, total: agg.total, durationMs: dt, timestamp: Date.now() };

      this._debugReport(payload);
      this._emit(payload);
      return payload;
    }

    // ----------------------------------------------------------------
    // Debug pretty printing
    // ----------------------------------------------------------------
    _debugPrintFinding(f) {
      try {
        const icon = f.passed ? "ðŸŸ¥" : "â¬œ";
        const hdr = `${icon} ${f.id}  (+${f.passed ? f.weight : 0}/${f.weight})`;
        console.groupCollapsed(`%c${hdr}`, f.passed ? "color:#ff7675" : "color:#8ab4f8");
        console.log("weightKey:", f.weightKey, "passed:", f.passed, "weight:", f.weight, "score:", f.score, "ts:", new Date(f.ts).toISOString());
        if (f.evidence && typeof f.evidence === "object") {
          try { console.table(f.evidence); } catch { console.log(f.evidence); }
        } else {
          console.log(f.evidence);
        }
        console.groupEnd();
      } catch {}
    }

    _debugReport(payload) {
      if (!this.opts.debug) return;
      try {
        const color = payload.suspected ? "background:#2b090b;color:#ffb3b3;padding:2px 6px;border-radius:6px" : "background:#0c2a12;color:#a3f2b6;padding:2px 6px;border-radius:6px";
        console.group(`%cAntiMonkey scan: score=${payload.score} suspected=${payload.suspected} (${payload.gained}/${payload.total}) in ${payload.durationMs}ms`, color);
        const tableData = payload.findings.map(f => ({
          id: f.id, passed: f.passed, weight: f.weight, score: f.score
        }));
        console.table(tableData);
        console.groupEnd();
      } catch {}
    }

    // ----------------------------------------------------------------
    // Heuristic #1: Image probe to chrome-extension://<id>/path
    // ----------------------------------------------------------------
    async _probeExtensionImage() {
      const evid = [], hits = [];
      const allIds = [
        ...KNOWN_IDS.chrome.tampermonkey, ...KNOWN_IDS.chrome.violentmonkey,
        ...KNOWN_IDS.edge.tampermonkey, ...KNOWN_IDS.edge.violentmonkey,
        ...KNOWN_IDS.opera.tampermonkey, ...KNOWN_IDS.opera.violentmonkey
      ];
      const tryId = (id) => new Promise(resolve => {
        try {
          const img = new Image();
          let done = false; const path = EXT_RESOURCES[rand(0, EXT_RESOURCES.length-1)];
          img.onload = () => { if (!done) { done = true; resolve({ id, ok:true, path }); } };
          img.onerror = () => { if (!done) { done = true; resolve({ id, ok:false, path }); } };
          img.src = `chrome-extension://${id}${path}?r=${Math.random()}`;
          setTimeout(() => { if (!done) { done = true; resolve({ id, ok:false, path, timeout:true }); } }, 1200);
        } catch { resolve({ id, ok:false, error:true }); }
      });
      const res = await Promise.all(allIds.map(tryId));
      for (const r of res) if (r.ok) { evid.push(`image:${r.id}${r.path}`); hits.push(r.id); }
      return this._addFinding("probeExtensionImage", hits.length>0, { hits, evid }, "probeExtensionImage");
    }

    // #2: link rel=stylesheet probe
    async _probeExtensionStylesheet() {
      const evid = [], hits = [];
      const allIds = [
        ...KNOWN_IDS.chrome.tampermonkey, ...KNOWN_IDS.chrome.violentmonkey,
        ...KNOWN_IDS.edge.tampermonkey, ...KNOWN_IDS.edge.violentmonkey,
        ...KNOWN_IDS.opera.tampermonkey, ...KNOWN_IDS.opera.violentmonkey
      ];
      const tryId = (id) => new Promise(resolve => {
        let link;
        try {
          link = document.createElement("link"); link.rel = "stylesheet";
          let done = false; const path = EXT_RESOURCES[rand(0, EXT_RESOURCES.length-1)];
          link.onload = () => { if (!done) { done = true; cleanup(); resolve({ id, ok:true, path }); } };
          link.onerror = () => { if (!done) { done = true; cleanup(); resolve({ id, ok:false, path }); } };
          link.href = `chrome-extension://${id}${path}?r=${Math.random()}`;
          document.documentElement.appendChild(link);
          function cleanup(){ try{link.remove();}catch{} }
          setTimeout(() => { if (!done) { done = true; cleanup(); resolve({ id, ok:false, path, timeout:true }); } }, 1200);
        } catch { resolve({ id, ok:false, error:true }); }
      });
      const res = await Promise.all(allIds.map(tryId));
      for (const r of res) if (r.ok) { evid.push(`css:${r.id}${r.path}`); hits.push(r.id); }
      return this._addFinding("probeExtensionStylesheet", hits.length>0, { hits, evid }, "probeExtensionStylesheet");
    }

    // #3: ResourceTiming scan of moz/chrome-extension
    async _scanResourceTimings() {
      try {
        const entries = performance.getEntriesByType("resource") || [];
        const ext = entries.filter(e => typeof e.name === "string" && (e.name.startsWith("chrome-extension://") || e.name.startsWith("moz-extension://"))).map(e => e.name);
        return this._addFinding("scanResourceTimings", ext.length>0, { ext }, "scanResourceTimings");
      } catch { return this._addFinding("scanResourceTimings", false, { error:true }, "scanResourceTimings"); }
    }

    // #4: DOM scan for extension scripts
    async _scanDOMForExtensionScripts() {
      try {
        const hits = Array.from(document.scripts).map(s => s.src||"").filter(src => src.startsWith("chrome-extension://") || src.startsWith("moz-extension://"));
        return this._addFinding("scanDOMForExtensionScripts", hits.length>0, { hits }, "scanDOMForExtensionScripts");
      } catch { return this._addFinding("scanDOMForExtensionScripts", false, { error:true }, "scanDOMForExtensionScripts"); }
    }

    // #5: stylesheet hrefs
    async _scanStylesForExtensionHrefs() {
      try {
        const hits = [];
        for (const sh of Array.from(document.styleSheets||[])) {
          const href = sh && sh.href || "";
          if (href && (href.startsWith("chrome-extension://") || href.startsWith("moz-extension://"))) hits.push(href);
        }
        return this._addFinding("scanStylesForExtensionHrefs", hits.length>0, { hits }, "scanStylesForExtensionHrefs");
      } catch { return this._addFinding("scanStylesForExtensionHrefs", false, { error:true }, "scanStylesForExtensionHrefs"); }
    }

    // #6: XHR hook
    async _detectXHRHook() {
      try {
        const o = XMLHttpRequest && XMLHttpRequest.prototype;
        const openLooks = o && looksNative(o.open);
        const sendLooks = o && looksNative(o.send);
        return this._addFinding("detectXHRHook", !(openLooks && sendLooks), { openLooks, sendLooks }, "detectXHRHook");
      } catch { return this._addFinding("detectXHRHook", false, { error:true }, "detectXHRHook");}
    }

    // #7: fetch hook
    async _detectFetchHook() {
      try {
        const fetchNative = looksNative(window.fetch);
        return this._addFinding("detectFetchHook", !fetchNative, { fetchNative }, "detectFetchHook");
      } catch { return this._addFinding("detectFetchHook", false, { error:true }, "detectFetchHook"); }
    }

    // #8: WebSocket hook
    async _detectWebSocketHook() {
      try {
        const ctorNative = looksNative(window.WebSocket);
        const sendNative = window.WebSocket && window.WebSocket.prototype && looksNative(window.WebSocket.prototype.send);
        return this._addFinding("detectWebSocketHook", !(ctorNative && sendNative), { ctorNative, sendNative }, "detectWebSocketHook");
      } catch { return this._addFinding("detectWebSocketHook", false, { error:true }, "detectWebSocketHook"); }
    }

    // #9: console tamper
    async _detectConsoleHook() {
      try {
        const c = console||{};
        const hooks = ["log","warn","error","debug","info","table","trace","group","groupCollapsed","groupEnd"].map(k => ({k, native: looksNative(c[k])}));
        const anyNon = hooks.some(h => !h.native);
        return this._addFinding("detectConsoleHook", anyNon, { hooks }, "detectConsoleHook");
      } catch { return this._addFinding("detectConsoleHook", false, { error:true }, "detectConsoleHook"); }
    }

    // #10: toString tamper (local realm)
    async _detectToStringTamper() {
      try {
        const ts = Function.prototype.toString;
        const tsNative = looksNative(ts);
        const baseNative = NATIVE_RX.test(Function.prototype.toString.call(Object.prototype.toString));
        return this._addFinding("detectToStringTamper", !(tsNative && baseNative), { tsNative, baseNative }, "detectToStringTamper");
      } catch { return this._addFinding("detectToStringTamper", false, { error:true }, "detectToStringTamper"); }
    }

    // #11/#12: mutation traps / ad bait
    _prepareMutationBait() {
      if (this._mo) return;
      try {
        const bait = document.createElement("div");
        bait.id=`tm-bait-${Math.random().toString(36).slice(2)}`; bait.setAttribute("data-bait","script-injection");
        bait.innerHTML="<span style='display:none'>bait</span>";
        appendHidden(bait); this._bait = bait;

        const mo = new MutationObserver((muts) => {
          for (const m of muts) {
            if (m.type === "childList") {
              for (const n of Array.from(m.addedNodes||[])) try{
                const tag = n.tagName?.toLowerCase()||"";
                if (tag==="script") {
                  const src = n.src||"";
                  if (src.startsWith("chrome-extension://") || src.startsWith("moz-extension://"))
                    this._addFinding("mutationScriptTrap", true, { src }, "mutationScriptTrap");
                }
              }catch{}
            }
          }
        });
        mo.observe(document.documentElement || document.body, { childList:true, subtree:true, attributes:true, attributeFilter:["src","href","class","data-*"] });
        this._mo = mo;
      } catch(e) { this._dwarn("mutation observer unavailable", e); }
    }

    async _mutationScriptTrapCheck() {
      try {
        const hit = Array.from(document.scripts).find(s => (s.src||"").startsWith("chrome-extension://") || (s.src||"").startsWith("moz-extension://"));
        return this._addFinding("mutationScriptTrap", !!hit, { preScanHit: !!hit, src: hit?.src ?? null }, "mutationScriptTrap");
      } catch { return this._addFinding("mutationScriptTrap", false, { error:true }, "mutationScriptTrap"); }
    }

    _prepareAdBait() {
      if (this._adBait) return;
      try {
        const b = document.createElement("div");
        b.id=`ad-banner-${Math.random().toString(36).slice(2)}`;
        b.className="ad ad-banner adsbox"; b.textContent="advertisement";
        appendHidden(b); this._adBait = b;
      } catch {}
    }

    async _baitAdRemovalTrapCheck() {
      try {
        if (!this._adBait) return this._addFinding("baitAdRemovalTrap", false, { prepared:false }, "baitAdRemovalTrap");
        const cs = getComputedStyle(this._adBait);
        const hidden = cs && (cs.display==="none"||cs.visibility==="hidden"||cs.opacity==="0");
        const r = this._adBait.getBoundingClientRect();
        const collapsed = r.width===0 || r.height===0;
        const removed = !document.documentElement.contains(this._adBait);
        return this._addFinding("baitAdRemovalTrap", (hidden||collapsed||removed), { hidden, collapsed, removed }, "baitAdRemovalTrap");
      } catch { return this._addFinding("baitAdRemovalTrap", false, { error:true }, "baitAdRemovalTrap"); }
    }

    // #13: timing anomaly
    async _timingAnomalyCheck() {
      try {
        const samples=8, deltas=[]; let last=now();
        for (let i=0;i<samples;i++) { await new Promise(r=>setTimeout(r,0)); const t=now(); deltas.push(t-last); last=t; }
        const avg = deltas.reduce((a,b)=>a+b,0)/Math.max(1,deltas.length);
        const spikes = deltas.filter(d=>d>8).length;
        return this._addFinding("timingAnomaly", (avg>4 && spikes>=2), { avg, spikes, deltas }, "timingAnomaly");
      } catch { return this._addFinding("timingAnomaly", false, { error:true }, "timingAnomaly"); }
    }

    // #14: window props
    async _checkWindowProps() {
      try {
        const keys=["GM_info","GM","GM_addStyle","GM_getValue","unsafeWindow","Violentmonkey","VM","Tampermonkey"];
        const present = keys.filter(k => { try { return k in window; } catch { return false; }});
        return this._addFinding("checkWindowProps", present.length>0, { present }, "checkWindowProps");
      } catch { return this._addFinding("checkWindowProps", false, { error:true }, "checkWindowProps"); }
    }

    // #15: stack leak
    async _stackMozExtensionLeak() {
      try {
        const err = new Error("__am_stack_probe__");
        const stack = (err.stack||"")+"";
        const hit = /moz-extension:\/\//i.test(stack) || /chrome-extension:\/\//i.test(stack);
        return this._addFinding("stackMozExtensionLeak", hit, { stack: hit ? stack.slice(0,400) : null }, "stackMozExtensionLeak");
      } catch { return this._addFinding("stackMozExtensionLeak", false, { error:true }, "stackMozExtensionLeak"); }
    }

    // #16: iframe scan
    async _detectExtensionIframes() {
      try {
        const hits = Array.from(document.getElementsByTagName("iframe")).map(f => f.src||"").filter(src => src.startsWith("chrome-extension://") || src.startsWith("moz-extension://"));
        return this._addFinding("detectExtensionIframes", hits.length>0, { hits }, "detectExtensionIframes");
      } catch { return this._addFinding("detectExtensionIframes", false, { error:true }, "detectExtensionIframes"); }
    }

    // ---------------- NEW: fresh-realm anti-masking utilities ----------------
    async _withFreshRealm(cb) {
      return new Promise((resolve) => {
        const f = document.createElement("iframe");
        f.style.display="none";
        f.srcdoc = "<!doctype html><meta charset=utf-8>";
        f.onload = () => {
          try { const w = f.contentWindow; resolve(cb(w)); }
          catch (e) { resolve({ error:true, msg: String(e) }); }
          finally { try { f.remove(); } catch{} }
        };
        document.documentElement.appendChild(f);
      });
    }

    // NEW #17: freshToStringMismatch â€” compare local FP.toString vs fresh realm
    async _freshToStringMismatch() {
      try {
        const r = await this._withFreshRealm((fw) => {
          const freshTS = fw.Function.prototype.toString;
          const localTS = Function.prototype.toString;
          const eq = freshTS === localTS;
          const freshNative = NATIVE_RX.test(freshTS.call(localTS));
          const localAsSeenByFresh = NATIVE_RX.test(freshTS.call(freshTS));
          return { eq, freshNative, localAsSeenByFresh };
        });
        // suspicious if not eq OR fresh sees local as non-native
        const passed = !!(r && (!r.eq || (r.freshNative && !r.localAsSeenByFresh)));
        return this._addFinding("freshToStringMismatch", passed, r, "freshToStringMismatch");
      } catch { return this._addFinding("freshToStringMismatch", false, { error:true }, "freshToStringMismatch"); }
    }

    // NEW #18: crossRealmConsoleProbe â€” fresh realm toString on page console.log
    async _crossRealmConsoleProbe() {
      try {
        const r = await this._withFreshRealm((fw) => {
          const sFreshOnPage = fw.Function.prototype.toString.call(console.log);
          const sLocal = Function.prototype.toString.call(console.log);
          const sFreshOnFresh = fw.Function.prototype.toString.call(fw.console.log);
          const looksNativeFreshOnPage = NATIVE_RX.test(sFreshOnPage);
          const looksNativeLocal = NATIVE_RX.test(sLocal);
          const looksNativeFreshOnFresh = NATIVE_RX.test(sFreshOnFresh);
          const mismatch = (sFreshOnPage !== sLocal) || !looksNativeFreshOnFresh;
          return { sFreshOnPage, sLocal, sFreshOnFresh, looksNativeFreshOnPage, looksNativeLocal, looksNativeFreshOnFresh, mismatch };
        });
        const passed = !!(r && (r.mismatch || (r.looksNativeFreshOnPage && !r.looksNativeLocal)));
        return this._addFinding("crossRealmConsoleProbe", passed, r, "crossRealmConsoleProbe");
      } catch { return this._addFinding("crossRealmConsoleProbe", false, { error:true }, "crossRealmConsoleProbe"); }
    }

    // NEW #19: descriptorWeirdness â€” console.log property descriptor sanity
    async _descriptorWeirdness() {
      try {
        const d = safeDesc(console, "log") || {};
        const weird = (typeof console.log === "function") && (d.configurable === true || d.enumerable === true);
        return this._addFinding("descriptorWeirdness", weird, { descriptor:d }, "descriptorWeirdness");
      } catch { return this._addFinding("descriptorWeirdness", false, { error:true }, "descriptorWeirdness"); }
    }
  }

  // Expose + auto-start (set debug/threshold as needed)
  window.AntiMonkey = AntiMonkey;

  AntiMonkey.start({
    debug: true,          // set to false in prod
    threshold: 35,        // suspicion threshold (0..100)
    continuous: true,
    onScore: ({ score, suspected, durationMs }) => {
      // lightweight ping (leave empty or wire telemetry)
     console.log("[AM] score:", score, "suspected:", suspected, "in", durationMs, "ms");
    },
    onDetect: (p) => {
     console.warn("[AM] DETECTED", p);
    }
  });

})();
</script>
</body>
